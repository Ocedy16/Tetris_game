import pygame
pygame.init()
pygame.display.set_mode((600,700))
clock=pygame.time.clock
running=True


S = [['.....',
      '......',
      '..00..',
      '.00...',
      '.....'],
     ['.....',
      '..0..',
      '..00.',
      '...0.',
      '.....']]

Z = [['.....',
      '.....',
      '.00..',
      '..00.',
      '.....'],
     ['.....',
      '..0..',
      '.00..',
      '.0...',
      '.....']]

I = [['..0..',
      '..0..',
      '..0..',
      '..0..',
      '.....'],
     ['.....',
      '0000.',
      '.....',
      '.....',
      '.....']]

O = [['.....',
      '.....',
      '.00..',
      '.00..',
      '.....']]

J = [['.....',
      '.0...',
      '.000.',
      '.....',
      '.....'],
     ['.....',
      '..00.',
      '..0..',
      '..0..',
      '.....'],
     ['.....',
      '.....',
      '.000.',
      '...0.',
      '.....'],
     ['.....',
      '..0..',
      '..0..',
      '.00..',
      '.....']]

L = [['.....',
      '...0.',
      '.000.',
      '.....',
      '.....'],
     ['.....',
      '..0..',
      '..0..',
      '..00.',
      '.....'],
     ['.....',
      '.....',
      '.000.',
      '.0...',
      '.....'],
     ['.....',
      '.00..',
      '..0..',
      '..0..',
      '.....']]

T = [['.....',
      '..0..',
      '.000.',
      '.....',
      '.....'],
     ['.....',
      '..0..',
      '..00.',
      '..0..',
      '.....'],
     ['.....',
      '.....',
      '.000.',
      '..0..',
      '.....'],
     ['.....',
      '..0..',
      '.00..',
      '..0..',
      '.....']]
#Autre façon de voir les formes. A tester. Mettre toutes les coordonées des zéros dans des listes à l'intérieur d'une liste 
T= [[[2,1],[2,2],[1,2],[3,2]],[[2,1],[2,2],[2,3],[3,2]],[[1,2],[2,2],[3,2],[2,3]],[[2,1],[2,2],[2,3],[1,2]]]

#Ainsi de suite avec les autres. Puis lier cela aux coordonnées de la pièce. Ex: le x et le y de la pièce représentent tout en haut à gauche de la pièce et
#les x et y de combien on doit "bouger" pour tomber sur le bloc. Il faut donc considérer les blocs indépendamment. Peut être implémenter qqc dans la classe.
#Une chose à tester pour voir si la méthode est la bonne: implémenter une classe dans un autre fichier avec les 4 coordonnées du bloc. Voir si modifier
#Le x et le y du bloc change bien les sous coordonnées automatiquement. En gros, est ce que le calcul se fait automatiquement. Je pense que oui mais j'aimerais
#Être sûre. 

formes=[T,S,L,J,O,I,Z]
class piece(object):
    def __init__(self,colonne=4,ligne=0,forme):
        self.x=colonne
        self.y=ligne
        self.couleur=self.forme.couleur
        self.rotation=0
        self.forme=forme[rotation] 
        #Voir pour peut être ajouter un sous accès liste si on accède d'abord aux formes.
        self.bloc_1=[x+self.forme[0][0],y+self.forme[0][1]]
        self.bloc_1=[x+self.forme[1][0],y+self.forme[1][1]]
        self.bloc_1=[x+self.forme[2][0],y+self.forme[2][1]]
        self.bloc_1=[x+self.forme[3][0],y+self.forme[3][1]]
        
       

def creer_grille(grille_finie={}):
    grille=[[(0,0,0) for x in range(10)] for y in range(20)] #Reinitialisation de la grille. Le tuple indique la couleur
    
   #Ici le but est d'afficher la grille en fonction des informations stockées. 
    for i in range (len(grille)):
        for j in range(len(grille[i])):
            if (j,i) in grille_finie:
                c = grille_finie[(j,i)]
                grille[i][j] = c
    return grille


def convertir_orientation_piece(piece):
      l=len(piece.forme)
      if piece.rotation + 1 < l:
            piece.rotation+=1
      else:
            piece.rotation=0
      

def espace_valide(piece, grille):
      #Tester pour les 4 coordonnées de piece si elles ne "fusionnent" pas avec une case non noir. Renvoyer True or False
      


def verifier_defaite(grille_finie):
      i=0
      while i<len(grille[0]):
            if grille_finie[(0,i)]!=(0,0,0):
                  return True
            i=i+1
      return False


def get_shape():
    global forme, couleur_forme
    random_index = random.randint(0,len(forme)-1)
    piece.forme=forme[random_index]



def ecrire_texte_milieu (texte, taille, couleur, surface):


def dessiner_grille(surface, grille_finie):
#Pour chaque élément dans la grille, dessiner sa couleur


def retirer_lignes_pleine(grille, grille_finie):
#Si une ligne est remplie, la supprimer de grille finie. 
#Mettre du while car plusieurs lignes peuvent être détruites à la fois

def dessiner_prochaine_piece(piece, surface):


def dessiner_fenetre(surface):


def main():
evenements = pygame.event.get()
for evenement in evenements:
    if evenement.type == pygame.KEYDOWN:
        if evenement.key == pygame.K_LEFT:
            piece.x -= 1
            if not(espace_valide(piece, grille)):
                  piece.x+=1
        if evenement.key == pygame.K_RIGHT:
            piece.x+=1
            if not(espace_valide(piece, grille)):
                  piece.x -= 1
        if evenement.key == pygame.K_DOWN:
            piece.y+=1
            if not(espace_valide(piece, grille)):
                  piece.y -= 1
                  #fin du tour. Enregistrer les coordonnées de la pièce dans grille finie
        if evenement.key == pygame.K_SPACE:
            piece_2=piece
            convertir_orientation_piece(piece_2)
            if espace_valide(piece_2, grille):
                  convertir_orientation_piece(piece)


def main_menu():
      #Print cliquer sur n'importe quelle touche au milieu en grand
      if evenement.type == pygame.KEYDOWN:
            main()

main_menu()
