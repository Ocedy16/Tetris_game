import pygame
import random
from pygame.locals import * # importer les constantes



S = [['.....',
      '......',
      '..00..',
      '.00...',
      '.....'],
     ['.....',
      '..0..',
      '..00.',
      '...0.',
      '.....']]

Z = [['.....',
      '.....',
      '.00..',
      '..00.',
      '.....'],
     ['.....',
      '..0..',
      '.00..',
      '.0...',
      '.....']]

I = [['..0..',
      '..0..',
      '..0..',
      '..0..',
      '.....'],
     ['.....',
      '0000.',
      '.....',
      '.....',
      '.....']]

O = [['.....',
      '.....',
      '.00..',
      '.00..',
      '.....']]

J = [['.....',
      '.0...',
      '.000.',
      '.....',
      '.....'],
     ['.....',
      '..00.',
      '..0..',
      '..0..',
      '.....'],
     ['.....',
      '.....',
      '.000.',
      '...0.',
      '.....'],
     ['.....',
      '..0..',
      '..0..',
      '.00..',
      '.....']]

L = [['.....',
      '...0.',
      '.000.',
      '.....',
      '.....'],
     ['.....',
      '..0..',
      '..0..',
      '..00.',
      '.....'],
     ['.....',
      '.....',
      '.000.',
      '.0...',
      '.....'],
     ['.....',
      '.00..',
      '..0..',
      '..0..',
      '.....']]

T = [['.....',
      '..0..',
      '.000.',
      '.....',
      '.....'],
     ['.....',
      '..0..',
      '..00.',
      '..0..',
      '.....'],
     ['.....',
      '.....',
      '.000.',
      '..0..',
      '.....'],
     ['.....',
      '..0..',
      '.00..',
      '..0..',
      '.....']]
#Autre façon de voir les formes. A tester. Mettre toutes les coordonées des zéros dans des listes à l'intérieur d'une liste
T= [[[2,1],[2,2],[1,2],[3,2]],[[2,1],[2,2],[2,3],[3,2]],[[1,2],[2,2],[3,2],[2,3]],[[2,1],[2,2],[2,3],[1,2]]]
L=[[[3,1],[3,2],[1,2],[2,2]],[[2,1],[2,2],[2,3],


#Ainsi de suite avec les autres. Puis lier cela aux coordonnées de la pièce. Ex: le x et le y de la pièce représentent tout en haut à gauche de la pièce et
#les x et y de combien on doit "bouger" pour tomber sur le bloc. Il faut donc considérer les blocs indépendamment. Peut être implémenter qqc dans la classe.
#Une chose à tester pour voir si la méthode est la bonne: implémenter une classe dans un autre fichier avec les 4 coordonnées du bloc. Voir si modifier
#Le x et le y du bloc change bien les sous coordonnées automatiquement. En gros, est ce que le calcul se fait automatiquement. Je pense que oui mais j'aimerais
#Être sûre.

formes=[T,S,L,J,O,I,Z]
class Piece(object):
    def __init__(self,forme,colonne,ligne):
        self.x=colonne
        self.y=ligne
        self.couleur=self.formes.couleur
        self.rotation=0
        self.forme=forme[self.rotation]
        #Voir pour peut être ajouter un sous accès liste si on accède d'abord aux formes.
        self.bloc_1=[self.x+self.forme[0][0],self.y+self.forme[0][1]]
        self.bloc_2=[self.x+self.forme[1][0],self.y+self.forme[1][1]]
        self.bloc_3=[self.x+self.forme[2][0],self.y+self.forme[2][1]]
        self.bloc_4=[self.x+self.forme[3][0],self.y+self.forme[3][1]]
    def deplacer(self):
        self.bloc_1=[self.x+self.forme[0][0],self.y+self.forme[0][1]]
        self.bloc_2=[self.x+self.forme[1][0],self.y+self.forme[1][1]]
        self.bloc_3=[self.x+self.forme[2][0],self.y+self.forme[2][1]]
        self.bloc_4=[self.x+self.forme[3][0],self.y+self.forme[3][1]]
    def tourner (self,forme):
        self.forme=forme[self.rotation]
        self.bloc_1=[self.x+self.forme[0][0],self.y+self.forme[0][1]]
        self.bloc_2=[self.x+self.forme[1][0],self.y+self.forme[1][1]]
        self.bloc_3=[self.x+self.forme[2][0],self.y+self.forme[2][1]]
        self.bloc_4=[self.x+self.forme[3][0],self.y+self.forme[3][1]]
      

# ce que j'ai codé pour définir les blocs, c'est toujours la même idée mais je trouve ça plus clair que les tableaux S,Z,... au début
# par contre il y a peut-être des erreurs ou oublis quand j'ai défini les propriété d'un bloc/tetros

# les couleurs qui correspondent aux blocs dans le jeu classique
couleur_forme = [[0, 255, 255], [255, 255, 0], [255, 0, 0], [0, 255, 0], [255, 0, 255], [255, 100 ,10], [0, 0, 100]] # cyan, jaune, rouge, vert, violet, orange, navy




def creer_grille(grille_finie):
    grille=[[(0,0,0) for x in range(10)] for y in range(20)] #Reinitialisation de la grille. Le tuple indique la couleur

   #Ici le but est d'afficher la grille en fonction des informations stockées.
    for i in range (len(grille)):
        for j in range(len(grille[i])):
            if (j,i) in grille_finie:
                c = grille_finie[(j,i)]
                grille[i][j] = c
    return grille


def convertir_orientation_piece(piece):
      l=len(piece.forme)
      if (piece.rotation + 1) < l:
            piece.rotation=piece.rotation+1
      else:
            piece.rotation=0

def save_dict (piece,grille_finie) :
    grille_finie [(piece.bloc_1[0], piece.bloc_1[1])] = piece.couleur
    grille_finie [(piece.bloc_2[0], piece.bloc_2[1])] = piece.couleur
    grille_finie [(piece.bloc_3[0], piece.bloc_3[1])] = piece.couleur
    grille_finie [(piece.bloc_4[0], piece.bloc_4[1])] = piece.couleur
  


def espace_valide(piece, grille_finie):
      
      if ((piece.bloc_1[0], piece.bloc_1[1]) in grille_finie) or ((piece.bloc_2[0], piece.bloc_2[1]) in grille_finie) or ((piece.bloc_3[0], piece.bloc_3[1]) in grille_finie) or ((piece.bloc_4[0], piece.bloc_4[1]) in grille_finie) :
            return False
      else :
            return True



def verifier_defaite(grille_finie):
      i=0
      while i<len(grille[0]):
            if grille_finie[(0,i)]!=(0,0,0):
                  return True
            i=i+1
      return False


def get_shape():
    global formes, couleur_forme
    return Piece(random.choice(formes), 3, -1)
    
def dessiner_piece(new_piece):
      pygame.draw.rect(fenetre, new_piece.couleur, (50+new_piece.bloc_1[0]*15, 50+new_piece.bloc_1[1]*15, 13, 13))
      pygame.draw.rect(fenetre, new_piece.couleur, (50+new_piece.bloc_2[0]*15, 50+new_piece.bloc_2[1]*15, 13, 13))
      pygame.draw.rect(fenetre, new_piece.couleur, (50+new_piece.bloc_3[0]*15, 50+new_piece.bloc_3[1]*15, 13, 13))
      pygame.draw.rect(fenetre, new_piece.couleur, (50+new_piece.bloc_4[0]*15, 50+new_piece.bloc_4[1]*15, 13, 13))
      pygame.display.update()
      pygame.init()
      

def ecrire_texte_milieu (texte, taille, couleur, surface):
    return 0


def dessiner_grille(grille):
#Pour chaque élément dans la grille, dessiner sa couleur
    for i in range (20) :
        for j in range (10) :
                #if (j, i) in grille_finie :
                    #for i in range (3) :
            pygame.draw.rect(fenetre, grille[i][j], (50+j*15, 50+i*15, 13, 13))
    pygame.display.update()
    pygame.init()

def effacer_ligne(grille_finie,i):
    for j in range (10):
        grille_finie[i][j]==(0,0,0)

def retirer_lignes_pleine(grille, grille_finie):
    while i<20:
        while j<10:
            if grille_finie[i][j]==(0,0,0):
                i=i+1
                j=0
            else:
                j=j+1
        effacer_ligne(grille_finie,i)
        j=0
        i=i+1


def main():
    clock=pygame.time.Clock()
    running=True
    grille_finie={}
    grille=creer_grille(grille_finie)
    dessiner_grille(grille)
    piece=get_shape()
    dessiner_piece(piece)
    image_time = 0
    while running==True:
        current_time = pygame.time.get_ticks()
        if image_time >= 0 and current_time >= image_time:
            image_time = current_time + 1000
        if current_time >= image_time:
            piece.y+=1
            if not(espace_valide(piece, grille_finie)):
                            piece.y -= 1
                            save.dict(piece,grille_finie)
                            get_shape()
                            
            else:
                  grille=creer_grille(grille_finie)
                  dessiner_grille(grille)
                  piece.deplacer()
                  dessiner_piece(piece)
        grille=creer_grille(grille_finie)
        for event in pygame.event.get():
            if event.type==pygame.QUIT:
                running = False
                pygame.display.quit()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_LEFT:
                    piece.x -= 1
                    if not(espace_valide(piece, grille)):
                        piece.x+=1
                    else:
                        grille=creer_grille(grille_finie)
                        dessiner_grille(grille)
                        piece.deplacer()
                        dessiner_piece(piece)
                if event.key == pygame.K_RIGHT:
                    piece.x+=1
                    if not(espace_valide(piece, grille)):
                        piece.x -= 1
                    else:
                        grille=creer_grille(grille_finie)
                        dessiner_grille(grille)
                        piece.deplacer()
                        dessiner_piece(piece)
                if event.key == pygame.K_DOWN:
                        piece.y+=1
                        if not(espace_valide(piece, grille_finie)):
                            piece.y -= 1
                            save.dict(piece,grille_finie)
                            get_shape()
                            
                        else:
                              grille=creer_grille(grille_finie)
                              dessiner_grille(grille)
                              piece.deplacer()
                              dessiner_piece(piece)
                  
                if event.key == pygame.K_SPACE:
                    #piece_2=piece
                    convertir_orientation_piece(piece)
                    if espace_valide(piece, grille_finie):
                        convertir_orientation_piece(piece)
                        grille=creer_grille(grille_finie)
                        dessiner_grille(grille)
                        piece.tourner()
                        dessiner_piece(piece)


def main_menu():
      #Print cliquer sur n'importe quelle touche au milieu en grand
      if evenement.type == pygame.KEYDOWN:
            main()
pygame.init()
fenetre=pygame.display.set_mode((600,700))
fenetre.fill((255,255,255)) #pour avoir un fond blanc
main()


